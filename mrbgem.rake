#!ruby

require_relative "buildlib/internals"

unless Rake::Task.task_defined?("check-mruby-gemcut")
  desc "generate dependency files for mruby-gemcut"
  task "check-mruby-gemcut" do
    puts "mruby-gemcut: Passed your design!"
  end
end

using Gemcut::Internals

MRuby::Gem::Specification.new("mruby-gemcut") do |s|
  s.summary = "runtime reconfigurer for mruby gems"
  version = File.read(File.join(File.dirname(__FILE__), "README.ja.md")).scan(/^ *[-*] version: *(\d+(?:.\w+)+)/i).flatten[-1] rescue nil
  s.version = version if version
  s.license = "BSD-2-Clause"
  s.author  = "dearblue"
  s.homepage = "https://github.com/dearblue/mruby-gemcut"

  # for `mrb_protect()`
  add_dependency "mruby-error", core: "mruby-error" if Gemcut.need_error_gem?

  class << self
    def include_testtools
      self.bins = %w(mruby-gemcut-test)
    end

    def add_droplist(*gems)
      gems.each { |e| e.ensure_string }
      @models[0].drop.concat gems
      self
    end
    alias add_blacklist add_droplist

    def add_model(name, bundle: nil, pass: nil, drop: nil)
      name = name.ensure_string
      raise NameError, "bad empty `name` for model" if name.empty?
      raise NameError, "already exist model `name` - #{name}" if @models.find { |m| m.name == name }

      bundle = bundle.ensure_array_or_nil
      pass = pass.ensure_array_or_state
      drop = drop.ensure_array_or_state
      raise ArgumentError, "need the `bundle`, `pass` or `drop` parameter" if bundle.empty? && pass.empty? && drop.empty?
      raise ArgumentError, "the `pass` and `drop` parameter are exclusive" unless pass.empty? || drop.empty?

      case
      when pass == true
        drop = false
      when pass == false
        drop = true
      when drop == true
        pass = false
      when drop == false
        pass = true
      end

      @models << Gemcut::Model.new(name, bundle, pass, drop, caller)

      self
    end
  end

  @models = [Gemcut::Model.new(nil, [], [], [], caller)]

  if cc.command =~ /\b(?:g?cc|clang)d*\b/
    cc.flags << %w(-Wno-declaration-after-statement)
  end


  # ここから下は全部 mruby-gemcut/deps.h のためのコード

  hdrgendir = File.join(build_dir, "include")
  deps_h = File.join(hdrgendir, "mruby-gemcut/deps.h")
  gemcut_o = File.join(build_dir, "src/mruby-gemcut.c").ext(exts.object)
  cc.include_paths << hdrgendir
  file gemcut_o => [File.join(dir, "src/mruby-gemcut.c"), deps_h]
  task "check-mruby-gemcut" => deps_h
  file deps_h => [__FILE__, File.join(build.build_dir, "mrbgems/gem_init.c")] do |t|
    # NOTE: file タスク中であれば build.gems はすでに依存関係が解決されている状態。

    verbose = Rake.respond_to?(:verbose) ? Rake.verbose : $-v
    puts %(GEN   #{t.name}#{verbose ? " (by #{__FILE__})" : nil}\n)

    gindex = build.gems.each_with_index.with_object({}) { |(g, i), a| a[g.name] = i }
    gems = build.gems.map do |g|
      name = "#{g.name}"
      cname = name.gsub(/[^0-9A-Za-z_]+/, "_")
      Gemcut::Entry[name, cname, g, g.dependencies.map { |e| gindex[e[:gem].to_s] }.sort]
    end

    gemcut_max_gems = 4000
    if gems.size > gemcut_max_gems
      raise "The allowable gem number in '#{s.name}' has been exceeded (maximum #{gemcut_max_gems})"
    end

    models = @models.dup
    models.map! do |m|
      bundle = m.bundle.build_pass_list_for("bundle list", gems, gindex, [], [], m.backtrace)
      pass = m.pass.build_pass_list_for("pass list", gems, gindex, bundle, (m.name ? models[0].drop : []), m.backtrace)
      drop = m.drop.build_drop_list_for("drop list", gems, gindex, bundle, m.backtrace)
      drop |= models[0].drop if m.name
      bundle.check_conflict_set(gems, drop, %(incorrect GEM contained in both "bundle list" and "drop list"), m.backtrace)
      pass.check_conflict_set(gems, drop, %(incorrect GEM contained in both "pass list" and "drop list"), m.backtrace)
      Gemcut::Model.new(m.name, bundle, pass, drop, m.backtrace)
    end

    unit_bits = 32

    FileUtils.mkpath File.dirname t.name
    File.write t.name, <<-"DEPS_H", mode: "wb"
/*
 * This file is auto generated by mruby-gemcut.
 * THE DATA YOU CHANGED WILL BE LOST.
 */

/* NOTE: `struct mgem_spec` is defined in `mruby-gemcut/src/mruby-gemcut.c` */

#define MGEMS_POPULATION #{gems.size}
#define MGEMS_BITMAP_UNITS #{gems.empty? ? 1 : (gems.size + (unit_bits - 1)) / unit_bits}
#define MGEMS_UNIT_BITS #{unit_bits}
typedef uint32_t bitmap_unit;

struct gemcut_model
{
  const char *name;
  bitmap_unit bundle[MGEMS_BITMAP_UNITS];
  bitmap_unit avail[MGEMS_BITMAP_UNITS];
};

#{
  gems.each_with_object("") { |g, a|
    next unless g.gem.generate_functions

    a << "\n" unless a.empty?
    a << "void GENERATED_TMP_mrb_#{g.cname}_gem_init(mrb_state *);\n" \
         "void GENERATED_TMP_mrb_#{g.cname}_gem_final(mrb_state *);"
  }
}

#{
  gems.each_with_object("") { |g, a|
    next if g.deps.empty?

    deplist = g.deps.map { |d| %(#{d}) }.join(", ")
    a << "\n" unless a.empty?
    a << %(static const uint16_t deps_#{g.cname}[] = { #{deplist} };)
  }
}

static const struct mgem_spec mgems_list[] = {
  #{
    gems.each_with_object("").with_index { |(g, a), i|
      if g.gem.generate_functions
        init = "GENERATED_TMP_mrb_#{g.cname}_gem_init"
        final = "GENERATED_TMP_mrb_#{g.cname}_gem_final"
      else
        init = final = "NULL"
      end

      if g.deps.empty?
        depsname = "NULL"
      else
        depsname = "deps_#{g.cname}"
      end

      no = "/* %3d */" % i

      a << ",\n  " unless a.empty?
      a << %(#{no} { #{g.name.inspect}, #{init}, #{final}, #{g.deps.size}, #{depsname} })
    }
  }
};

static const struct gemcut_model gemcut_models[] = {
  #{
    dest = []
    models.each do |m|
      avail = m.pass.empty? ? (gems.size.times.to_a - m.drop) : m.pass
      bundle = m.bundle.make_bitmap([0] * ((gems.size + 31) / 32))
      avail = avail.make_bitmap(bundle.dup)
      bundle = bundle.map { |e| "0x%08xUL" % e }.join(", ")
      avail = avail.map { |e| "0x%08xUL" % e }.join(", ")
      dest << "{ #{m.name&.inspect || "NULL"}, { #{bundle} }, { #{avail} } }"
    end
    dest.join(",\n  ")
  }
};
    DEPS_H
  end
end
