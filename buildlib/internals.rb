begin
  require "mruby/source"
rescue LoadError
  $: << File.join(MRUBY_ROOT, "lib")
  require "mruby/source"
end

module Gemcut
  def Gemcut.need_error_gem?
    MRuby::Source::MRUBY_RELEASE_NO < 30100 and !File.exist?(File.join(MRUBY_ROOT, "mrbgems/mruby-binding"))
  end

  module Internals
    refine MRuby::Gem::Specification do
      # mruby-gemcut/deps.h を生成するためのタスク
      def make_depsfile_task
        hdrgendir = File.join(build_dir, "include")
        deps_h = File.join(hdrgendir, "mruby-gemcut/deps.h")
        gemcut_o = File.join(build_dir, "src/mruby-gemcut.c").ext(exts.object)
        cc.include_paths << hdrgendir
        file gemcut_o => [File.join(dir, "src/mruby-gemcut.c"), deps_h]
        file deps_h => [__FILE__, File.join(build.build_dir, "mrbgems/gem_init.c")] do |t|
          # NOTE: file タスク中であれば build.gems はすでに依存関係が解決されている状態。

          verbose = Rake.respond_to?(:verbose) ? Rake.verbose : $-v
          puts %(GEN   #{t.name}#{verbose ? " (by #{__FILE__})" : nil}\n)

          gindex = {}
          gems = build.gems.map.with_index do |g, i|
            name = g.name.to_s
            cname = name.gsub(/[^0-9A-Za-z_]+/, "_")
            gindex[name] = i
            [name, cname, g, g.dependencies.map { |e| e[:gem].to_s }, !@blacklist.include?(name)]
          end

          gemcut_max_gems = 4000
          if gems.size > gemcut_max_gems
            raise "The allowable gem number in '#{s.name}' has been exceeded (maximum #{gemcut_max_gems})"
          end

          unit_bits = 32

          FileUtils.mkpath File.dirname t.name
          File.write t.name, <<~"DEPS_H", mode: "wb"
            /*
             * This file is auto generated by mruby-gemcut.
             * THE DATA YOU CHANGED WILL BE LOST.
             */

            /* NOTE: `struct mgem_spec` is defined in `mruby-gemcut/src/mruby-gemcut.c` */

            #define MGEMS_POPULATION #{gems.size}
            #define MGEMS_BITMAP_UNITS #{gems.empty? ? 1 : (gems.size + (unit_bits - 1)) / unit_bits}
            #define MGEMS_UNIT_BITS #{unit_bits}
            typedef uint32_t bitmap_unit;

            #{
              gems.each_with_object("") { |(name, cname, gem, deps, avail), a|
                next unless gem.generate_functions

                if a.empty?
                  a << <<~DEF
                    #define NULL_GEMFUNC_PAIR() NULL, NULL
                    #define MAKE_GEMFUNC_PAIR(CNAME) GENERATED_TMP_mrb_ ## CNAME ## _gem_init, GENERATED_TMP_mrb_ ## CNAME ## _gem_final

                    typedef void init_final_f(mrb_state *);

                  DEF
                else
                  a << "\n"
                end
                a << "init_final_f MAKE_GEMFUNC_PAIR(#{cname});" \
              }
            }

            #{
              gems.each_with_object("") { |(name, cname, gem, deps, avail), a|
                next if deps.empty?

                deps = deps.map { |d| gindex[d] }.sort
                deplist = deps.map { |d| %(#{d}) }.join(", ")
                a << "\n" unless a.empty?
                a << %(static const uint16_t deps_#{cname}[] = { #{deplist} };)
              }
            }

            static const struct mgem_spec mgems_list[] = {
              #{
                gems.each_with_object("").with_index { |((name, cname, gem, deps, avail), a), i|
                  if gem.generate_functions
                    funcpair = "MAKE_GEMFUNC_PAIR(#{cname})"
                  else
                    funcpair = "NULL_GEMFUNC_PAIR()"
                  end

                  if deps.empty?
                    depsname = "NULL"
                  else
                    depsname = "deps_#{cname}"
                  end

                  no = "/* %3d */" % i

                  a << ",\n  " unless a.empty?
                  a << %(#{no} { #{name.inspect}, #{funcpair}, #{avail ? "TRUE" : "FALSE"}, #{deps.size}, #{depsname} })
                }
              }
            };
          DEPS_H
        end
      end
    end
  end
end
